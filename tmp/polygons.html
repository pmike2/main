<!--
Partie client
-->

<!DOCTYPE html>
<html>
	<head>
		<title>TEST</title>
		<style>
			#svg_emprise {
				fill: rgb(200, 200, 200);
			}
			#svg_main_group {
				
			}
			line {
				stroke: rgb(255,0,0);
				stroke-width: 0.005;
			}
			line:hover {
				stroke-width: 0.01;
			}
			circle {
				r: 0.005;
			}
			circle:hover {
				r: 0.01;
			}
		</style>
	</head>
	<body>
		<svg id="svg_main" width="600" height="600" viewBox="0.0 0.0 1.0 1.0" onload="svg_init()">
			<rect id="svg_emprise" width="100%" height="100%"/>
			<g id="svg_main_group" transform="matrix(1.0 0.0 0.0 -1.0 0.0 1.0)"></g>
			<!-- transform sert à avoir une origine en bas à gauche -->
		</svg>

		<script>
			var svg_main_group, svg_emprise;
			var svg_width, svg_height;
			var current_polygon_idx= null;
			var current_point_idx= null;
			var current_line_idx= null;
			var editing_mode= null;
			var polygons= [];
			var keypresseds= {};
			var move_polygon_start_position= null;


			function normalized_coords(x, y) {
				return {"x" : x/ svg_width, "y" : 1.0- y/ svg_height};
			}

			function norm(p) {
				return Math.sqrt(p.x* p.x+ p.y* p.y);
			}

			function diff(p1, p2) {
				return {"x" : p1.x- p2.x, "y" : p1.y- p2.y};
			}

			function simplify_coords(coords, treshold, min_dist) {
				function alignement(p1, p2, p3) {
					let scal= (p2.x- p1.x)* (p3.x- p1.x)+ (p2.y- p1.y)* (p3.y- p1.y);
					let n12= Math.sqrt((p2.x- p1.x)* (p2.x- p1.x)+ (p2.y- p1.y)* (p2.y- p1.y));
					let n13= Math.sqrt((p3.x- p1.x)* (p3.x- p1.x)+ (p3.y- p1.y)* (p3.y- p1.y));
					if ((n12< 1e-7) || (n13< 1e-7)) {
						console.log("pb simplify_coords")
						return 1.0;
					}
					return scal/ (n12* n13);
				}

				if (coords.length< 3) {
					return coords;
				}

				let result= [];
				result.push(coords[0]);
				let base= 0;
				let base2= 1;
				let tested= 2;
				let done= false;
				
				while (true) {
					while (norm(diff(coords[base], coords[base2]))< min_dist) {
						base2+= 1;
						if (base2== coords.length- 1) {
							done= true;
							result.push(coords[coords.length- 1]);
							break;
						}
					}
					if (done) {
						break;
					}
					tested= base2+ 1;
					
					while (alignement(coords[base], coords[base2], coords[tested])> treshold) {
						tested+= 1;
						if (tested== coords.length) {
							done= true;
							result.push(coords[coords.length- 1]);
							break;
						}
					}
					if (done) {
						break;
					}
					
					result.push(coords[tested- 1]);
					base= tested- 1;
					base2= tested;
					if (base2== coords.length- 1) {
						break;
					}
				}
				return result;
			}


			function clear() {
				polygons= [];
			}


			function add_polygon() {
				polygons.push([]);
				return polygons.length- 1;
			}


			function remove_polygon(idx_polygon) {
				polygons.splice(idx_polygon, 1);
			}


			function duplicate_polygon(idx_polygon) {
				polygons.push(JSON.parse(JSON.stringify(polygons[idx_polygon])));
				move_polygon(polygons.length- 1, {"x" : 0.1, "y" : 0.1});
			}


			function set_polygon(idx_polygon, polygon) {
				polygons[idx_polygon]= [];
				for (let i=0; i<polygon.length; ++i) {
					if ("x" in polygon[i]) {
						polygons[idx_polygon].push({"x" : polygon[i].x, "y" : polygon[i].y});
					}
					else {
						polygons[idx_polygon].push({"x" : polygon[i][0], "y" : polygon[i][1]});
					}
				}
			}


			function move_polygon(idx_polygon, v) {
				for (let i=0; i<polygons[idx_polygon].length; ++i) {
					polygons[idx_polygon][i].x+= v.x;
					polygons[idx_polygon][i].y+= v.y;
				}
			}


			function simplify_polygon(idx_polygon, treshold, min_dist) {
				let simplified= simplify_coords(polygons[idx_polygon], treshold, min_dist);
				polygons[idx_polygon]= simplified;
			}


			function scale_polygon(idx_polygon, factor) {
				
			}


			function add_point(idx_polygon, coord) {
				polygons[idx_polygon].push(coord);
			}


			function add_point_on_line(idx_polygon, idx_line, coord) {
				polygons[idx_polygon].splice(idx_line+ 1, 0, coord);
			}


			function remove_point(idx_polygon, idx_point) {
				polygons[idx_polygon].splice(idx_point, 1);
			}


			function move_point(idx_polygon, idx_point, coord) {
				polygons[idx_polygon][idx_point]= coord;
			}


			function get_point_idx(svg_id) {
				return [
					parseInt(svg_id.split("polygon_")[1].split("_")[0]),
					parseInt(svg_id.split("point_")[1])
				];
			}


			function get_line_idx(svg_id) {
				return [
					parseInt(svg_id.split("polygon_")[1].split("_")[0]),
					parseInt(svg_id.split("line_")[1])
				];
			}


			function get_svg_polygon_id(idx_polygon) {
				return "polygon_"+ idx_polygon;
			}


			function get_svg_point_id(idx_polygon, idx_point) {
				return "polygon_"+ idx_polygon+ "_point_"+ idx_point;
			}


			function get_svg_line_id(idx_polygon, idx_line) {
				return "polygon_"+ idx_polygon+ "_line_"+ idx_line;
			}


			function null_ids() {
				current_polygon_idx= null;
				current_point_idx= null;
				current_line_idx= null;
			}


			function update_polygon_group(idx_polygon) {
				let polygon_group= document.getElementById(get_svg_polygon_id(idx_polygon));
				if (polygon_group=== null) {
					polygon_group= document.createElementNS("http://www.w3.org/2000/svg", "g");
					polygon_group.setAttribute("id", get_svg_polygon_id(idx_polygon));
					svg_main_group.appendChild(polygon_group);
				}
				else {
					polygon_group.innerHTML= "";
				}
				
				for (let i=0; i<polygons[idx_polygon].length; ++i) {
					polygon_group.innerHTML+= '<line x1="'+ polygons[idx_polygon][i].x+ '" y1="'+ polygons[idx_polygon][i].y+ 
						'" x2="'+ polygons[idx_polygon][(i+ 1) % polygons[idx_polygon].length].x+
						'" y2="'+ polygons[idx_polygon][(i+ 1) % polygons[idx_polygon].length].y+
						'" class="lines" id="'+ get_svg_line_id(idx_polygon, i)+ '" />\n';
				}
				for (let i=0; i<polygons[idx_polygon].length; ++i) {
					polygon_group.innerHTML+= '<circle cx="'+ polygons[idx_polygon][i].x+ '" cy="'+ polygons[idx_polygon][i].y+ 
						'" class="points" id="'+ get_svg_point_id(idx_polygon, i)+ '" />\n';
				}
				let svg_points= polygon_group.getElementsByClassName("points");
				for (let i=0; i<svg_points.length; ++i) {
					svg_points[i].addEventListener("mousedown", mouse_down_point);
					svg_points[i].addEventListener("mouseup", mouse_up_point);
				}
				let svg_lines= polygon_group.getElementsByClassName("lines");
				for (let i=0; i<svg_lines.length; ++i) {
					svg_lines[i].addEventListener("mousedown", mouse_down_line);
					svg_lines[i].addEventListener("mouseup", mouse_up_line);
				}
			}


			function delete_polygon_group(idx_polygon) {
				let polygon2delete= document.getElementById(get_svg_polygon_id(idx_polygon));
				if (polygon2delete!== null) {
					polygon2delete.remove();
				}
				for (let i=idx_polygon+ 1; i<polygons.length ;++i) {
					//update_polygon_group(polygons[i]);
					let polygon= document.getElementById(get_svg_polygon_id(i));
					polygon.setAttribute("id", get_svg_polygon_id(i- 1));
					for (let j=0; j<polygons[i].length; ++j) {
						let point= document.getElementById(get_svg_point_id(i, j));
						point.setAttribute("id", get_svg_point_id(i- 1, j));
					}
					for (let j=0; j<polygons[i].length; ++j) {
						let line= document.getElementById(get_svg_line_id(i, j));
						line.setAttribute("id", get_svg_line_id(i- 1, j));
					}
				}
			}


			function delete_all_polygon_groups() {
				svg_main_group.innerHTML= "";
			}


			function update_point_position(idx_polygon, idx_point) {
				let svg_point= document.getElementById(get_svg_point_id(idx_polygon, idx_point));
				svg_point.setAttribute("cx", polygons[idx_polygon][idx_point].x);
				svg_point.setAttribute("cy", polygons[idx_polygon][idx_point].y);

				let svg_line_before;
				if (idx_point> 0) {
					svg_line_before= document.getElementById(get_svg_line_id(idx_polygon, idx_point- 1));
				}
				else {
					svg_line_before= document.getElementById(get_svg_line_id(idx_polygon, polygons[idx_polygon].length- 1));
				}
				svg_line_before.setAttribute("x2", polygons[idx_polygon][idx_point].x);
				svg_line_before.setAttribute("y2", polygons[idx_polygon][idx_point].y);

				let svg_line_after= document.getElementById(get_svg_line_id(idx_polygon, idx_point));
				svg_line_after.setAttribute("x1", polygons[idx_polygon][idx_point].x);
				svg_line_after.setAttribute("y1", polygons[idx_polygon][idx_point].y);
			}

			
			function update_polygon_position(idx_polygon) {
				for (let i=0; i<polygons[idx_polygon].length; ++i) {
					update_point_position(idx_polygon, i);
				}
			}


			function svg_init() {
				svg_width= document.getElementById("svg_main").getAttribute("width");
				svg_height= document.getElementById("svg_main").getAttribute("height");
				svg_main_group= document.getElementById("svg_main_group");
				svg_emprise= document.getElementById("svg_emprise");
				svg_emprise.addEventListener("mousedown", mouse_down_emprise);
				svg_emprise.addEventListener("mouseup", mouse_up_emprise);
				svg_emprise.addEventListener("mousemove", mouse_move_emprise);
				svg_emprise.addEventListener("mouseout", mouse_out_emprise);

				document.addEventListener("keydown", function(event) {
					keypresseds[event.key]= true;
				});
				document.addEventListener("keyup", function(event) {
					keypresseds[event.key]= false;
				});
			}


			function mouse_down_emprise(e) {
				//console.log(e.offsetX+ " ; "+ e.offsetY);
				if (keypresseds['c']) {
					delete_all_polygon_groups();
					clear();
				}
				else {
					editing_mode= "CREATE";
					current_polygon_idx= add_polygon();
					add_point(current_polygon_idx, normalized_coords(e.offsetX, e.offsetY));
				}
			}


			function mouse_up_emprise(e) {
				//console.log(e.offsetX+ " ; "+ e.offsetY);
				if (editing_mode== "CREATE") {
					add_point(current_polygon_idx, normalized_coords(e.offsetX, e.offsetY));
					simplify_polygon(current_polygon_idx, 0.99999, 0.01);
					update_polygon_group(current_polygon_idx);
				}
				else if (editing_mode== "MOVE_POINT") {
					null_ids();
				}
				else if (editing_mode== "MOVE_POLYGON") {
					null_ids();
				}
				editing_mode= null;
			}


			function mouse_move_emprise(e) {
				if (editing_mode== "CREATE") {
					add_point(current_polygon_idx, normalized_coords(e.offsetX, e.offsetY));
				}
				else if (editing_mode== "MOVE_POINT") {
					move_point(current_polygon_idx, current_point_idx, normalized_coords(e.offsetX, e.offsetY));
					update_point_position(current_polygon_idx, current_point_idx);
				}
				else if (editing_mode== "MOVE_POLYGON") {
					let current_position= normalized_coords(e.offsetX, e.offsetY);
					move_polygon(current_polygon_idx, {"x" : current_position.x- move_polygon_start_position.x, "y" : current_position.y- move_polygon_start_position.y});
					move_polygon_start_position= {"x" : current_position.x, "y" : current_position.y};
					update_polygon_position(current_polygon_idx);
				}
			}


			function mouse_out_emprise(e) {
				if ((e.offsetX< 2) || (e.offsetX> svg_width- 3) || (e.offsetY< 2) || (e.offsetY> svg_height- 3)) {
					editing_mode= null;
					null_ids();
				}
			}


			function mouse_down_point(e) {
				[current_polygon_idx, current_point_idx]= get_point_idx(e.target.id);

				if (keypresseds['d']) {
					remove_point(current_polygon_idx, current_point_idx);
					update_polygon_group(current_polygon_idx);
					null_ids();
				}
				else if (keypresseds['c']) {
					delete_polygon_group(current_polygon_idx);
					remove_polygon(current_polygon_idx);
					null_ids();
				}
				else {
					editing_mode= "MOVE_POINT";
				}
				//if (e.shiftKey) {/*shift is down*/
				/*if (e.altKey) {}
				if (e.ctrlKey) {}
				if (e.metaKey) {}*/
			}


			function mouse_up_point(e) {
				editing_mode= null;
				null_ids();
			}


			function mouse_down_line(e) {
				[current_polygon_idx, current_line_idx]= get_line_idx(e.target.id);

				if (keypresseds['a']) {
					add_point_on_line(current_polygon_idx, current_line_idx, normalized_coords(e.offsetX, e.offsetY));
					update_polygon_group(current_polygon_idx);
					null_ids();
				}
				else if (keypresseds['p']) {
					duplicate_polygon(current_polygon_idx);
					update_polygon_group(polygons.length- 1);
					null_ids();
				}
				else {
					editing_mode= "MOVE_POLYGON";
					move_polygon_start_position= normalized_coords(e.offsetX, e.offsetY);
				}
			}


			function mouse_up_line(e) {
				editing_mode= null;
				null_ids();
			}


		</script>
	</body>
</html>
